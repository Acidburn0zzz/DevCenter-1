---
layout: tutorial
title: Using LDAP Login Module to authenticate users with LDAP server in hybrid applications
relevantTo: [hybrid]
---
<ul>
<li class="download-sample">
          <a href="http://public.dhe.ibm.com/software/products/en/MobileFirstPlatform/docs/v630/LDAPLoginModuleHybridProject.zip">Download Studio project</a>
        </li>
</ul>

<h2>Overview</h2>
<p>You can use the <strong>LdapLoginModule</strong> class to authenticate users with LDAP servers such as OpenLDAP or Active Directory.<br />
The <strong>LdapLoginModule</strong> class implements the <strong>UserNamePasswordLoginModule</strong> interface. Therefore, it must be used in conjunction with an authenticator that implements the <strong>UsernamePasswordAuthenticator</strong> interface. For example: <strong>FormBasedAuthenticator</strong>.<br />
For more information about how to implement <strong>UsernamePasswordAuthenticator</strong> interface, see <a title="Custom Authenticator and Login Module" href="http://developer.ibm.com/mobilefirstplatform/documentation/getting-started-6-3/authentication-security/custom-authenticator-login-module/">Custom Authenticator and Login Module</a>.</p>
<p>In this tutorial, you learn how to configure and use the <strong>LdapLoginModule</strong> class to protect various IBM MobileFirst Platform Foundation entities.</p>
<h2>Configuring the authenticationConfig.xml file</h2>
<h3>Realm</h3>
<p>Add an authentication realm to the <code>realms</code> section of the <strong>authenticationConfig.xml</strong> file and call it <strong>LDAPRealm</strong>.<br />
Use <strong>FormBasedAuthenticator</strong> in the <code>className</code> element because it implements the required <strong>UsernamePasswordAuthenticator</strong> interface.<br />
This realm uses <strong>LDAPLoginModule</strong> as a login module, which will be defined later.</p>
<p>[code lang="xml"]<br />
<realm loginModule="LDAPLoginModule" name="LDAPRealm"&gt;<br />
  <className&gt;com.worklight.core.auth.ext.FormBasedAuthenticator</className&gt;<br />
</realm&gt;<br />
[/code]</p>
<p>To protect a specific resource add the <code>onLoginUrl</code> element as follow:<br />
[code lang="xml"]<br />
<realm loginModule="LDAPLoginModule" name="LDAPRealm"&gt;<br />
  <className&gt;com.worklight.core.auth.ext.FormBasedAuthenticator</className&gt;<br />
  <onLoginUrl&gt;/console</onLoginUrl&gt;<br />
</realm&gt;<br />
[/code]<br />
<br clear="all" /></p>
<h3>Login Module</h3>
<p>Add a login module to the <code>loginModules</code> section and call it <strong>LDAPLoginModule</strong>.</p>
<p>[code lang="xml"]<br />
<loginModule name="LDAPLoginModule"&gt;<br />
  <className&gt;com.worklight.core.auth.ext.LdapLoginModule</className&gt;<br />
  <parameter name="ldapProviderUrl" value="ldap://10.0.1.2" /&gt;<br />
  <parameter name="ldapTimeoutMs" value="2000" /&gt;<br />
  <parameter name="ldapSecurityAuthentication" value="simple" /&gt;<br />
  <parameter name="validationType" value="searchPattern" /&gt;<br />
  <parameter name="ldapSecurityPrincipalPattern" value="{username}@myserver.com" /&gt;<br />
  <parameter name="ldapSearchFilterPattern" value="(&amp;amp;(objectClass=user)(sAMAccountName={username})(memberof=CN=Sales,OU=Groups,OU=MyCompany,DC=myserver,DC=com))" /&gt;<br />
  <parameter name="ldapSearchBase" value="dc=myserver,dc=com" /&gt;<br />
</loginModule&gt;<br />
[/code]</p>
<p>Use <strong>com.worklight.core.auth.ext.LdapLoginModule</strong> in the <code>className</code> element.<br />
The <strong>ldapProviderUrl</strong> parameter is mandatory. It defines the URL of your LDAP server.<br />
The <strong>ldapTimeoutMs</strong> parameter is mandatory. It defines the timeout for LDAP server requests (in milliseconds).<br />
The <strong>ldapSecurityAuthentication</strong> parameter is mandatory. It defines the type of authentication that is required by LDAP server. The usual value is <code>simple</code>, but you might need to contact LDAP administrator for a more appropriate value.<br />
The <strong>validationType</strong> parameter is mandatory. It defines the type of validation that is performed.<br />
LdapLoginModule supports three types of validation:</p>
<ul>
<li><strong>exists</strong>: The login module tries to establish the LDAP binding by using the supplied credentials. The validation of the credentials is considered successful when binding is successfully established.</li>
<li><strong>searchPattern</strong>: The login module first tries to run the exists validation. After such validation is successful, the login module issues a search query to the LDAP server context according to the <code>ldapSearchFilterPattern</code> and <code>ldapSearchBase</code> parameters. Credential validation is considered successful if a search query returns one or more entries.</li>
<li><strong>custom</strong>: Use this value to enable a custom validation logic. The login module tries to run the exists validation after such validation is successful, the login module calls the <code>public boolean doCustomValidation(LdapContext ldapCtx, String username)</code> method. You can override this method by creating a custom Java class in your project and extending the <code>com.worklight.core.auth.ext.UserNamePasswordLoginModule</code> class.</li>
</ul>
<p>For more information about custom LDAP validation types, see the user documentation.</p>
<p>The <strong>ldapSecurityPrincipalPattern</strong> parameter is mandatory. It defines the pattern in which LDAP security principal is sent to the LDAP server. You can use a <code>{username}</code> placeholder to inject the user name from the authenticator.<br />
The <strong>ldapSearchFilterPattern</strong> and <strong>ldapSearchBase</strong> parameters are optional. They apply only to the <strong>searchPattern</strong> validation type.</p>
<h3>Security Test</h3>
<p>Add a security test to the <code>securityTests</code> section of the <strong>authenticationConfig.xml</strong> file.<br />
You use this security test to protect the adapter procedure. Therefore, use the <code>customSecurityTest</code> element.<br />
Remember the security test name as it will be needed later.</p>
<p>[code lang="xml"]<br />
<customSecurityTest name="LDAPSecurityTest"&gt;<br />
  <test realm="wl_directUpdateRealm" step="1" /&gt;<br />
  <test isInternalUserID="true" realm="LDAPRealm" /&gt;<br />
</customSecurityTest&gt;<br />
[/code]</p>
<h2>Protecting a JavaScript Adapter</h2>
<p>Create an adapter and name it <strong>DummyAdapter</strong>.<br />
Add a <code>getSecretData</code> procedure and protect it with the security test that you created in previously.</p>
<p>[code lang="xml"]<procedure name="getSecretData" securityTest="LDAPSecurityTest"/&gt;[/code]</p>
<p>In this module, the <code>getSecretData</code> procedure returns some hardcoded value:</p>
<p>[code lang="javascript"]<br />
function getSecretData(){<br />
    return {<br />
        secretData: '123456'<br />
    };<br />
}<br />
[/code]</p>
<h2>Protecting a Java Adapter</h2>
<p>Create a Java adapter. Add a <code>getSecretData</code> method and protect it with the realm you created previously. In this module, the <code>getSecretData</code> procedure returns some hardcoded value:</p>
<p>[code lang="java" highlight="3"]<br />
	@GET<br />
	@Produces("application/json")<br />
	@OAuthSecurity(scope="LDAPRealm")<br />
	public JSONObject getSecretData(){<br />
		JSONObject result = new JSONObject();<br />
		result.put("secretData", "123456");</p>
<p>		return result;<br />
	}<br />
[/code]</p>
<p>To set our new realm as the default user identity for the application, in the application descriptor, add this option:<br />
[code lang="xml"]<br />
<userIdentityRealms&gt;LDAPRealm</userIdentityRealms&gt;<br />
[/code]</p>
<h2>Creating the client-side authentication components</h2>
<p>The application consists of two main <code>div</code> elements:<br />
The <code>AppDiv</code> element is used to display the application content.<br />
The <code>AuthDiv</code> element is used for authentication forms.<br />
When authentication is required, the application hides the <code>AppDiv</code> element and shows the <code>AuthDiv</code> element.<br />
When authentication is complete, it does the opposite.</p>
<p>[code lang="html"]<br />
<div id="AppDiv"&gt;<br />
  <input type="button" class="appButton" value="Call protected adapter proc" onclick="getSecretData()" /&gt;<br />
  <input type="button" class="appButton" value="Logout" onclick="WL.Client.logout('LDAPRealm',{onSuccess: WL.Client.reloadApp})" /&gt;<br />
  <p id="resultDiv"&gt;</p&gt;<br />
</div&gt;<br />
[/code]</p>
<p>The buttons are used to call the <strong>getSecretData</strong> procedure and to log out.</p>
<p>[code lang="html"]<br />
<div id="AuthDiv" style="display:none"&gt;<br />
  <div id="loginForm"&gt;<br />
    <input type="text" id="usernameInputField" placeholder="Enter username" /&gt;<br />
    <br /&gt;<br />
    <input type="password" placeholder="Enter password" id="passwordInputField" /&gt;<br />
    <br/&gt;<br />
    <input type="button" class="formButton" id="loginButton" value="Login" /&gt;<br />
    <input type="button" class="formButton" id="cancelButton" value="Cancel" /&gt;<br />
  </div&gt;<br />
</div&gt;<br />
[/code]</p>
<p>The <strong>AuthDiv</strong> is styled as <code>display:none</code>, because it must not be displayed before authentication is requested by server.</p>
<h3>Challenge Handler</h3>
<p>Use the <strong>WL.Client.createChallengeHandler</strong> method to create a challenge handler object. Supply a realm name as a parameter.</p>
<p>[code lang="javascript"]<br />
var LDAPRealmChallengeHandler = WL.Client.createChallengeHandler("LDAPRealm");<br />
[/code]</p>
<h3>isCustomResponse</h3>
<p>The <strong>isCustomResponse</strong> function of the challenge handler is called each time a response is received from the server. That function is used to detect whether the response contains data that are related to this challenge handler. It must return <code>true</code> or <code>false</code>.<br />
The default login form that is returned from the MobileFirst server contains the <code>j_security_check</code> string. If the challenge handler detects it in the response, it returns <code>true</code>.</p>
<p>[code lang="javascript"]<br />
LDAPRealmChallengeHandler.isCustomResponse = function(response) {<br />
    if (!response || !response.responseText) {<br />
        return false;<br />
    }</p>
<p>    var idx = response.responseText.indexOf("j_security_check");</p>
<p>    if (idx &gt;= 0){<br />
        return true;<br />
    }<br />
    return false;</p>
<p>};<br />
[/code]</p>
<h3>handleChallenge</h3>
<p>If the <strong>isCustomResponse</strong> method returns <code>true</code>, the framework calls the <strong>handleChallenge</strong> function. This function is used to perform required actions, such as hide the application screen or show the login screen.<br />
After the client application detects that the server sent a login form, which means that the server is requesting authentication, the application hides the <code>AppDiv</code>, shows the <code>AuthDiv</code>, and cleans up the <strong>passwordInputField</strong>.</p>
<p>[code language="javascript"]<br />
LDAPRealmChallengeHandler.handleChallenge = function(response){<br />
        $('#AppDiv').hide();<br />
        $('#AuthDiv').show();<br />
        $('#passwordInputField').val('');<br />
};<br />
[/code]</p>
<h3>Other methods</h3>
<p>In addition to the methods that the developer must implement, the challenge handler contains functionality that the developer might want to use:</p>
<ul>
<li>The <code>submitLoginForm</code> function sends collected credentials to a specific URL. The developer can also specify request parameters, headers, and callbacks.</li>
<li>The <code>submitSuccess</code> function notifies the framework that the authentication process completed successfully. The framework then automatically issues the original request that triggered authentication.</li>
<li>The <code>submitFailure</code> function notifies the framework that the authentication process completed with failure. The framework then disposes of the original request that triggered the authentication.</li>
</ul>
<ul>
<li>Note: You must attach each of these functions to its object. For example: <code>myChallengeHandler.submitSuccess()</code></li>
</ul>
<h3>Login Button</h3>
<p>A click on a <strong>login</strong> button triggers a function that collects the user name and password from the HTML input fields and submits them to the server.<br />
It is possible to set request headers here, and to specify callbacks.<br />
The form-based authenticator uses the hardcoded <code>j_security_check</code> URL component. You cannot have more than one instance of it.</p>
<p>[code lang="javascript"]<br />
$('#loginButton').bind('click', function () {<br />
    var reqURL = '/j_security_check';<br />
    var options = {};<br />
    options.parameters = {<br />
            j_username : $('#usernameInputField').val(),<br />
            j_password : $('#passwordInputField').val()<br />
    };<br />
    options.headers = {};<br />
    LDAPRealmChallengeHandler.submitLoginForm(reqURL, options, LDAPRealmChallengeHandler.submitLoginFormCallback);<br />
});<br />
[/code]</p>
<h3>Cancel Button</h3>
<p>A click on a <strong>cancel</strong> button hides the <code>AuthDiv</code>, shows the <code>AppDiv</code>, and notifies the framework that authentication failed.</p>
<p>[code lang="javascript"]<br />
$('#cancelButton').bind('click', function () {<br />
    $('#AppDiv').show();<br />
    $('#AuthDiv').hide();<br />
    LDAPRealmChallengeHandler.submitFailure();<br />
});<br />
[/code]</p>
<h3>submitLoginFormCallback</h3>
<p>The callback function checks the response for the containing server challenge again. If a challenge is found, the <code>handleChallenge</code> function is called again.<br />
No challenge present in the server response means that authentication completed successfully. In this case, <code>AppDiv</code> is shown, <code>AuthDiv</code> is hidden, and the framework is notified about the authentication success.</p>
<p>[code lang="javascript"]<br />
LDAPRealmChallengeHandler.submitLoginFormCallback = function(response) {<br />
    var isLoginFormResponse = LDAPRealmChallengeHandler.isCustomResponse(response);<br />
    if (isLoginFormResponse){<br />
        LDAPRealmChallengeHandler.handleChallenge(response);<br />
    } else {<br />
        $('#AppDiv').show();<br />
        $('#AuthDiv').hide();<br />
        LDAPRealmChallengeHandler.submitSuccess();<br />
    }<br />
};<br />
[/code]</p>
<h2>Sample application</h2>
<p><a href="http://public.dhe.ibm.com/software/products/en/MobileFirstPlatform/docs/v630/LDAPLoginModuleHybridProject.zip">Click to download</a> the Studio project.</p>
<p><a href="https://developer.ibm.com/mobileplatform/wp-content/uploads/sites/32/2014/07/09_11_results.png"><img class="aligncenter wp-image-1065 size-full" src="{{ site.baseurl }}/assets/backup/09_11_results.png" alt="09_11_results" width="1033" height="596" /></a></p>
