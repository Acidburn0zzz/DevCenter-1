---
layout: doc_page
title: One Time Password
date: 
type: doc_page
published: false
status: private
categories: []
tags:
- 6-3
meta:
  _wpcom_is_markdown: '1'
  _edit_last: '6643'
  _wpas_done_all: '1'
  _syntaxhighlighter_encoded: '1'
author:
  login: shmulikb@il.ibm.com
  email: shmulikb@il.ibm.com
  display_name: Shmulik Bardosh
  first_name: Shmulik
  last_name: Bardosh
---
<p class="breadcrumbs">
&lt; ... <a href="https://developer.ibm.com/mobilefirstplatform/documentation/getting-started-6-3/authentication-security/">Authentication and security</a></p>
<div id="samplesAndPersonas">
<div>
    Relevant to:</p>
<ul id="relevantForPersona">
<li class="hybrid"><a href="https://developer.ibm.com/mobilefirstplatform/documentation/getting-started-hybrid-development-6-3/">Hybrid</a></li>
</ul>
</div>
<ul>
<li class="download-sample">
          <a href="http://public.dhe.ibm.com/software/products/en/MobileFirstPlatform/docs/v630/OneTimePasswordProject.zip">Download Studio project</a>
        </li>
</ul>
</div>
<h2>Overview</h2>
<p>A One-Time Password (OTP) is a password that is valid for only one login session or transaction.</p>
<p>Unlike a static password, a one-time password changes each time the user logs in. The passwords themselves are generated in one of two ways: either as time-synchronized or counter-synchronized. Both approaches require that the server and the client application be synchronized, and both use the same algorithm to generate the password.</p>
<p>In this tutorial we will use the time-synchronized One Time Password (TOTP).</p>
<p>When using Time-synchronized One-Time Password the authentication server and the client application should be synchronized.<br />
If the authentication server and the user token don't keep the same time, then the expected One-Time Password value won't be produced and the user authentication will fail. With time-synchronized One-Time Password, the user typically must enter the password within a certain period of time before it's considered expired and another one must be generated.</p>
<p>In this tutorial we will use <strong>Google Authenticator</strong> (<a href="https://code.google.com/p/google-authenticator/" title="Google Authenticator" target="_blank">https://code.google.com/p/google-authenticator/</a>) as the client One-Time Password generator and validate it's given One-Time password using a Java class on the server side that calculates the OTP and validates it against the given value.</p>
<h2>Defining Security-Tests and Realms</h2>
<p>First create 2 Security-Tests:</p>
<ol>
<li><strong>DeviceEnrollmentSecurityTest</strong> - This Security-Test will be used to enroll the device before connecting to the server and generate the unique secret for the creation of the One-Time Password account. This security-Test will be using a Device-Provisioning realm (DeviceEnrollmentRealm)</li>
<li><strong>OneTimePasswordSecurityTest</strong> - This Security-Test will be used to validate a request from the client application to the server using the One-Time Password algorithm. This security-Test will be using an Adapter-Based-Authentication realm (OneTimePasswordRealm)</li>
</ol>
<p>[code lang="xml" title="authenticationConfig.xml"]<br />
&lt;securityTests&gt;<br />
  &lt;customSecurityTest name=&quot;SubscribeServlet&quot;&gt;<br />
    &lt;test realm=&quot;SubscribeServlet&quot; isInternalUserID=&quot;true&quot;/&gt;<br />
  &lt;/customSecurityTest&gt;</p>
<p>  &lt;mobileSecurityTest name=&quot;DeviceEnrollmentSecurityTest&quot;&gt;<br />
    &lt;testAppAuthenticity/&gt;<br />
    &lt;testDeviceId provisioningType=&quot;custom&quot; realm=&quot;DeviceEnrollmentRealm&quot;/&gt;<br />
  &lt;/mobileSecurityTest&gt;</p>
<p>  &lt;customSecurityTest name=&quot;OneTimePasswordSecurityTest&quot;&gt;<br />
    &lt;test isInternalUserID=&quot;true&quot; realm=&quot;OneTimePasswordRealm&quot;/&gt;<br />
  &lt;/customSecurityTest&gt;<br />
&lt;/securityTests&gt;</p>
<p>&lt;realms&gt;<br />
  &lt;realm name=&quot;DeviceEnrollmentRealm&quot; loginModule=&quot;DeviceEnrollmentLoginModule&quot;&gt;<br />
    &lt;className&gt;com.worklight.core.auth.ext.DeviceAutoProvisioningAuthenticator&lt;/className&gt;<br />
      &lt;parameter name=&quot;validate-csr-function&quot; value=&quot;MyAdapter.validateCSR&quot;/&gt;<br />
  &lt;/realm&gt;</p>
<p>  &lt;realm name=&quot;OneTimePasswordRealm&quot; loginModule=&quot;OneTimePasswordLoginModule&quot;&gt;<br />
    &lt;className&gt;com.worklight.integration.auth.AdapterAuthenticator&lt;/className&gt;<br />
    &lt;parameter name=&quot;login-function&quot; value=&quot;MyAdapter.onAuthRequired&quot;/&gt;<br />
    &lt;parameter name=&quot;logout-function&quot; value=&quot;MyAdapter.onLogout&quot;/&gt;<br />
  &lt;/realm&gt;</p>
<p>  &lt;realm name=&quot;SubscribeServlet&quot; loginModule=&quot;rejectAll&quot;&gt;<br />
    &lt;className&gt;com.worklight.core.auth.ext.HeaderAuthenticator&lt;/className&gt;<br />
  &lt;/realm&gt;<br />
&lt;/realms&gt;<br />
[/code]<br />
<br clear="all" /></p>
<h2>Client Side Code</h2>
<p>First, for the custom-device-provisioning to run when the application initialize we need to add the Security-Test inside the application-descriptor and protect each environment that we use. This Security-Test will be triggered once the application connects to the server.</p>
<p>[code lang="xml" title="application-descriptor.xml" highlight="1,9"]<br />
&lt;iphone securityTest=&quot;DeviceEnrollmentSecurityTest&quot; bundleId=&quot;com.OneTimePassword&quot; version=&quot;1.0&quot;&gt;<br />
  &lt;worklightSettings include=&quot;false&quot;/&gt;<br />
  &lt;security&gt;<br />
    &lt;encryptWebResources enabled=&quot;false&quot;/&gt;<br />
    &lt;testWebResourcesChecksum enabled=&quot;false&quot; ignoreFileExtensions=&quot;png, jpg, jpeg, gif, mp4, mp3&quot;/&gt;<br />
  &lt;/security&gt;<br />
&lt;/iphone&gt;</p>
<p>&lt;android securityTest=&quot;DeviceEnrollmentSecurityTest&quot; version=&quot;1.0&quot;&gt;<br />
  &lt;worklightSettings include=&quot;false&quot;/&gt;<br />
  &lt;security&gt;<br />
    &lt;encryptWebResources enabled=&quot;false&quot;/&gt;<br />
    &lt;testWebResourcesChecksum enabled=&quot;false&quot; ignoreFileExtensions=&quot;png, jpg, jpeg, gif, mp4, mp3&quot;/&gt;<br />
    &lt;publicSigningKey&gt;.......&lt;/publicSigningKey&gt;<br />
    &lt;packageName/&gt;<br />
  &lt;/security&gt;<br />
&lt;/android&gt;<br />
[/code]<br />
<br clear="all" /></p>
<p>Now we need to connect to the server once the application is initialized for the custom-device-provisioning security-test to be triggered, so let's use WL.Client.connect() method inside wlCommonInit().</p>
<p>[code lang="javascript" title="main.js"]<br />
function wlCommonInit(){<br />
  WL.Client.connect({<br />
    onFailure: onConnectFailure<br />
  });<br />
}<br />
[/code]<br />
<br clear="all" /></p>
<p>After we set the device-provisioning configuration we want to implement our next step, which is invoking 2 procedures. One that protects a secret data using the One-Time password mechanism, and another one that is not secured.</p>
<p>[code lang="javascript" title="main.js"]<br />
function getPublicResource()<br />
{<br />
	var invocationData = {<br />
			adapter : &quot;MyAdapter&quot;,<br />
			procedure: &quot;getPublicData&quot;,<br />
			parameters: []<br />
	};</p>
<p>	WL.Client.invokeProcedure(invocationData, {<br />
		onSuccess: getPublicResource_CallbackOK,<br />
		onFailure: getPublicResource_CallbackFail<br />
	});<br />
}</p>
<p>function getProtectedResource()<br />
{<br />
	var invocationData = {<br />
			adapter : &quot;MyAdapter&quot;,<br />
			procedure: &quot;getProtectedData&quot;,<br />
			parameters: []<br />
	};</p>
<p>	WL.Client.invokeProcedure(invocationData, {<br />
		onSuccess: getProtectedResource_CallbackOK,<br />
		onFailure: getProtectedResource_CallbackFail<br />
	});<br />
}<br />
[/code]<br />
<br clear="all" /></p>
<h3><em>Challenge-Handlers</em></h3>
<p>In this application we have to use 2 challenge-handlers. One for the device-provisioning process and for receiving the Secret that is being generated by the server, and second for the One-Time Password validation to be handled (using adapter-based authentication flow).</p>
<p>In the device-provisioning challenge-handler we generate a CSR (Certificate Signing Request) that is being sent to the server. This triggers the server to create a secret and send it back to the client when the processSuccess() method of the challenge-handler is being called (means that the server created a certificate for the device).</p>
<p>[code lang="javascript" title="DeviceEnrollmentRealmChallengeHandler.js" highlight="7"]<br />
deviceEnrollmentChallengeHandler.processSuccess = function(identity) {<br />
	WL.Logger.debug(&quot;processSuccess :: &quot; + JSON.stringify(identity));<br />
	$(&quot;#connectToServerButton&quot;).hide();</p>
<p>	$(&quot;#AppBody&quot;).show();<br />
	$(&quot;#ProvBody&quot;).hide();<br />
	$(&quot;#showSecretDiv&quot;).text(JSON.stringify(identity.attributes.customAttribute));<br />
};<br />
[/code]<br />
<br clear="all" /></p>
<p>Our second challenge-handler (the OneTimePassword challenge-handler) will be called when the user will try to get a protected resource. The user will then be asked to enter a One-Time Password. This will trigger the server to validate this One-Time Password and return the validation result. If the validation result is OK we will we then use the submitSuccess() method and grant access to the protected resource.</p>
<p>[code lang="javascript" title="OneTimePasswordRealmChallengeHandler.js" highlight="14,23-29"]<br />
oneTimePasswordRealmChallengeHandler.handleChallenge = function(response){<br />
	var authRequired = response.responseJSON.authRequired;</p>
<p>	if (authRequired == true){<br />
		$(&quot;#otpBody&quot;).show();<br />
		$(&quot;#otpTextBox&quot;).empty();</p>
<p>		if (response.responseJSON.errorMessage)<br />
	    	$(&quot;#otpInfo&quot;).html(response.responseJSON.errorMessage);</p>
<p>	} else if (authRequired == false){<br />
		$(&quot;#otpInfo&quot;).html(&quot;Your One-Time-Password validation completed successfuly. Now you can get access to your protected resource.&quot;);<br />
		$(&quot;#otpBody&quot;).hide();<br />
		oneTimePasswordRealmChallengeHandler.submitSuccess();<br />
	}<br />
};</p>
<p>$(&quot;#submitOTPButton&quot;).bind('click', function () {<br />
	var password = $(&quot;#otpTextBox&quot;).val();<br />
	$(&quot;#otpInfo&quot;).html(password);</p>
<p>	var invocationData = {<br />
		adapter : &quot;MyAdapter&quot;,<br />
		procedure : &quot;submitAuthentication&quot;,<br />
		parameters : [password]<br />
	};</p>
<p>	oneTimePasswordRealmChallengeHandler.submitAdapterAuthentication(invocationData, {});<br />
});<br />
[/code]<br />
<br clear="all" /></p>
<h2>Server Side Code</h2>
<h3><em>Adapter XML file</em>:</h3>
<p>In our adapter we have procedures for both the device-provisioning process and the One-Time Password process.<br />
The device-provisioning procedures (validateCSR / validateCertificate) are fired by the <strong><em>DeviceEnrollmentSecurityTest</em></strong> when the application launches - so no need for us to explicitly define it in the adapter XML file.<br />
The only procedure that has to be explicitly protected in the adapter XML file is <strong><em>getProtectedData</em></strong> which we use to retrieve our protected resource. We'll protect it using our <strong><em>OneTimePasswordSecurityTest</em></strong>.<br />
[code]&lt;procedure name=&quot;getProtectedData&quot; securityTest=&quot;OneTimePasswordSecurityTest&quot;&gt;&lt;/procedure&gt;[/code]<br />
<br clear="all" /></p>
<h3><em>Adapter JavaScript file</em>:</h3>
<p>When the application launches we use the custom-device-provisioning process to generate a unique secret using a combination of the application name and the device ID (This secret is being used to create an account in Google Authenticator or any other time-based authenticator program).</p>
<p>First we assign the application name and the device ID in 2 global variables so we can use them later in the procedures that run the One-Time Password validation. Here we use the CSR request content to get the application name and device ID.<br />
[code lang="javascript" title="MyAdapter.js"]<br />
MyAppId = csrContent.appId;<br />
MyDeviceID = csrContent.deviceId;<br />
[/code]<br />
<br clear="all" /></p>
<p>Next we call a java procedure that gets the application name and the device ID and returns a unique string that will be used as the secret value:<br />
[code lang="javascript" title="MyAdapter.js"]<br />
secret = com.mobilefirst.onetimepassword.CreateSecret.createSecret(MyAppId, MyDeviceID);<br />
secret = secret.substring(0,16);<br />
[/code]<br />
The secret should be no longer than 16 characters so we use JavaScript substring() method to select only the first 16 characters in case the returned value is longer than that.</p>
<p>Now we validate the credentials that the current user entered - if the validation passed then we pass the sercet to the client application using the customAttribute of the device-provisioning response.<br />
[code lang="javascript" title="MyAdapter.js" highlight="5"]<br />
if(csrContent.uName == &quot;mobilefirst&quot; &amp;&amp; csrContent.uPass == &quot;12345&quot;){<br />
  response = {<br />
    isSuccessful: true,<br />
    attributes: {<br />
      customAttribute: secret<br />
    }<br />
  };<br />
} else {<br />
  response = {<br />
    isSuccessful: false,<br />
    errors: [&quot;Invalid User Name &amp; Password&quot;]<br />
  };<br />
}<br />
return response;<br />
[/code]<br />
<br clear="all" /></p>
<p>When the user wants to reach the protected resource he should enter a one-time-password and send it to the server. When the one-time-password is being sent (submitOTPButton is clicked and generates an invocation of submitAuthentication procedure) :<br />
[code lang="javascript" title="OneTimePasswordRealmChallengeHandler.js" highlight="7"]<br />
$(&quot;#submitOTPButton&quot;).bind('click', function () {<br />
  var password = $(&quot;#otpTextBox&quot;).val();<br />
  $(&quot;#otpInfo&quot;).html(password);</p>
<p>  var invocationData = {<br />
    adapter : &quot;MyAdapter&quot;,<br />
    procedure : &quot;submitAuthentication&quot;,<br />
    parameters : [password]<br />
  };</p>
<p>  oneTimePasswordRealmChallengeHandler.submitAdapterAuthentication(invocationData, {});<br />
});<br />
[/code]<br />
<br clear="all" /></p>
<p>submitAuthentication procedure is the place where we validate the entered one-time-password.<br />
If the entered one-time-password is OK (passsed the validation) then we set an ActiveUser that is authorized to access the protected resource.<br />
[code lang="javascript" title="MyAdapter.js"]<br />
if (validateOTP(password) == true){<br />
  WL.Server.setActiveUser(&quot;OneTimePasswordRealm&quot;, userIdentity);<br />
  return {<br />
    authRequired: false<br />
  };<br />
}<br />
return onAuthRequired(null, &quot;Invalid Password&quot;);<br />
[/code]<br />
<br clear="all" /></p>
<h3><em>Java Classes</em>:</h3>
<p>In this sample we use 2 java classes that are being called from the adapter:</p>
<ol>
<li><strong><em>CreateSecret.java</em></strong> - a class that creates a valid secret for the One-Time Password process. This secret will be used by the user to create an account in <a href="https://code.google.com/p/google-authenticator/" title="Google Authenticator" target="_blank">Google Authenticator</a> or any other One-Time Password authenticator program so it has to follow the guide lines of the <a href="http://tools.ietf.org/html/rfc6238" title="TOTP RFC" target="_blank">TOTP (Time-Based One-Time Password Algorithm) RFC</a>.</li>
<li><strong><em>CheckOTP</em></strong> - a class that receives a one-time-password and validates it.</li>
</ol>
<h2>How to run this sample</h2>
<p><em>You need some TOTP (Time Based One-Time Password) authenticator program like <a href="https://code.google.com/p/google-authenticator/" title="Google Authenticator" target="_blank">Google Authenticator</a> installed on your device to run this sample</em>.</p>
<ol>
<li>Open you authenticator program.</li>
<li>Run the OneTimePassword application (the authenticator application will remain open in background).</li>
<li>The first screen is the Device Enrollment screen - Use "mobilefirst" as your user-name and "12345" as your password.</li>
<li>In the next screen you'll see your secret for the authenticator program- use it to create a new account.</li>
<li>Now click the "<em>My Protected Resource</em>" button</li>
<li>When you see the text field where you should enter your one-time-password - open your authenticator program and copy the current one-time-password.</li>
<li>Paste the password in the text field and press the "<em>Submit OTP</em>" button.</li>
<li>Now you should be able to access the protected resource.</li>
</ol>
<p>[caption id="attachment_3993" align="aligncenter" width="980"]<a href="http://developer.ibm.com/mobilefirstplatform/wp-content/uploads/sites/32/2014/11/app-screen-shots.png"><img src="{{ site.baseurl }}/assets/app-screen-shots-1024x547.png" alt="app-screen-shots" width="980" height="523" class="size-large wp-image-3993" /></a> app-screen-shots[/caption]</p>
