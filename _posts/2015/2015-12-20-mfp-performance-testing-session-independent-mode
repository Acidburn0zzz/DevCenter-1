---
title: 'MobileFirst Platform Foundation Performance Testing for Session Independent Mode (OAuth model)'
date: 2015-12-20
tags:
- MobileFirst_Platform
- Performance
- Testing
- OAuth
author:
  name: Nir Grande
---

The purpose of this page is to describe how to run performance tests on the different features of the MFP Server. In this post, an Apache JMeter performance test is used and Java classes are compiled especially for JMeter.

There are two descriptions in this post:
1. <a href="#MFP">MFP flow</a> - The standard MFP flow, starting from the client request and ending with the reception of a valid access token.
2. <a href="#Jmeter">Test flow</a> - A JMeter test flow that emulates an MFP client.
A zip file containing the files that are used in the JMeter flow below has been provided. Read more <a href="#Attachment">here</a>.

Before we describe the actual test flow, let us consider the OAuth flow:
<font size="6"><strong><em>OAuth flow with Java adapter</em></strong></font> 
The OAuth 2.0 protocol is based on acquiring an access token, which encapsulates the authorization that is granted to the client. In that context, the IBM MobileFirst Platform Server serves as an authorization server and is able to generate such tokens. The client can then use these tokens to access resources on a resource server, which can be either the MobileFirst Server itself, or an external server. The resource servers perform validation on the token to make sure that the client can be granted access to the requested resource. This separation between resource server and authorization server in the new OAuth-based model allows you to enforce MobileFirst security on resources that are running outside the MobileFirst Server.

<ul>
<a name="MFP"></a>
<font size="6"><strong>MFP flow</strong></font>
The resource in this flow is Java adapter     
<strong>Registration</strong> - This phase occurs once in the lifetime of a mobile app that is installed on a device. In this phase, the client registers itself with the MobileFirst Server. When application authenticity has been configured, it is activated during registration. 
<strong>Authorization</strong> - In this phase, the client has to undergo specific security checks, according to the scope of the authorization request. All the security checks supported by MobileFirst can be used in this phase (built-in realms such as remoteDisable and others, custom realms, and adapter-based authentication).  
<strong>Token</strong> - After successful authorization, the client is redirected to the token endpoint, where it is authenticated using the PKI trust that was established during the registration phase. The endpoint then generates two sets of tokens and sends them back to the client: an access token, which encapsulates all the security checks that the client has passed in the authorization phase and an ID token, which contains information regarding the user and device identity of the client.
<strong>Access resource</strong> - From this point it is possible to access the resource, either an adapter or an external resource, with a valid token.

<a name="Jmeter"></a>
<font size="6"><strong>JMeter Test flow</strong></font>    
<a href="#Prerequisite">Prerequisite</a> - Before running the script, ensure that the MFP Server is up. Deploy the application and also copy all the dependencies as mentioned below. 
<a href="#Registration">Registration</a> - <strong>In this test this step is bypassed by adding the clients directly to the database. It is a single action in the application life cycle that should have no effect on performance. </strong>
<a href="#Authorization">Authorization</a> - In the test, authorization is required for the <code>antiXSRF</code> and <code>deviceNoProvisioning</code> realms. This means that the client has to extract the correct instance id and device token in order to successfully pass the authorization phase and get a valid grant code. 
<a href="#Sign">Sign grant code</a> - This Java class mimics client behavior by signing the grant code that was received in the authorization phase.  
<a href="#Token">Token</a> - The client sends the signed grant code and receives an access token and ID token. These values are then extracted by JMeter.
<a href="#Call">A sample REST API call</a> - Shows how to access the resource endpoint with a valid token.

JMeter is used here for simulating an MFP client. It lets you use hundreds of threads, each thread holding a large number of fake devices. Using this method, you can stress the MFP server according to your needs. This flow describes a single client session with several requests. 
<ol>
<a name="Prerequisite"></a>    
<font size="5"><strong>Prerequisite</strong></font>
  <ul>
   1. Import the Java class that has been provided to the /lib/ext folder in JMeter.

    <img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/placingjar.png" alt="placingjar" />
    
   2. Deploy the <code>test</code> app. The application is needed for the registration procedure. The application is protected by the default security test that includes <code>antiXSRF</code> realm. If your app is protected by other realms, you must answer all these challenges successfully before getting the grant code.

    <img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/deploy-app.png" alt="deploy app" />
</ul>


<a name="Registration"></a>  
<font size="5"><strong>Registration</strong></font>  
The registration flow occurs during the first client server negotiation and is written to the <code>CLIENT_INSTANCES</code> table. Only registered clients can access MFP resources.
Registration is a single action that should have no effect on performance. We did not implement this operation inside JMeter script.
The <code>CLIENT INSTANCES</code> table has been populated with pairs of coordinated <code>client_id</code> and <code>device_id</code>. This data will be used later by JMeter.

The following SQL command inserts clients into the CLIENT_INSTANCES table:
insert into CLIENT_INSTANCES values (count ,'test','1.0','ANDROID',blob(x'30819F300D06092A864886F70D010101050003818D00308189028181009A8757DC39A58B28210FC8367385B2920C02C647C4A82411FFD5B0C0B60985EAE4A785760D1CB8213E01B1AABBA4D71031D769387F62D501690CF4E870D9A8E78A9A613E112CA9759B40C4F839E84E502880EEA56B5A316971C3E7D270A003DF4453FC4FC69247DD2B7204724599D60335B6F542C7FDD84380B1B7183E23A2C90203010001'),count,'Android-4.2.2','Lenovo S750');

You can use the DB2 sql script that is attached in the zip file below.
Parameters:
<ul>
<code>count</code> - Variable that represents the client id and device id
<code>test </code>- Application name 
<code>1.0</code> - Application version
<code>ANDROID </code>- Application environment
<code>blob </code>- Constant public key
</ul>

The default insert command assumes you have an application called <code>test </code>in an <code>ANDROID</code> environment. Ensure that you have deployed such a dummy application. Wrap this command according to your needs and to the tool you use.
Please note that the command inserts the public key that is used by the Java class. This value should not be changed.
</ol> 

<ol>
<a name="Authorization"></a>
<font size="5"><strong>Authorization</strong></font>
Authorization involves a set of requests, with which the client eventually receives a grant code after successfully handling all challenges. 

Send the appropriate headers for each request.
The following are the default headers for all requests:
<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/default-headers-1024x227.png" alt="default headers"/>
<ul>
<code>x-wl-app-version</code>: Version of your app
<code>x-wl-platform-version</code>: MFP platform version (for 7.1, do not change)
<code>X-WL-ClientId</code> - Client ID
<code>X-WL-Session</code> -  Any string for session ID 
</ul>

Now we will demonstrate the authorization process in two phases:
<ul>
<font size="4"><strong>Authorization1</strong></font> 
Sends a request to authorization in order to get the challenges back and extract them:
<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/no_provisioning.png" alt="no_provisioning" />

<ol>
<code>client id</code> - The client that is used during the session
<code>scope </code> - App is protected by <code>anti-XSRF</code>. We will add another challenge - <code>deviceNoProvisioning</code> - to the authorization by using the scope parameter. If you have a different authentication flow, change this parameter accordingly. 
</ol>
Use your own values for <code>scope</code> and <code>client id</code>. Leave all the other parameters as they appear here. 

the Server returns the <code>anti-XSRF</code> and <code>deviceNoProvisioning</code> realm challenges: 
<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/auth1response-1024x133.png" alt="auth1response" />

Extract the <code>wl-instance-Id</code> and the <code>device-token</code> from the response and send them as headers in all requests to the MFP Server. If you do not, the authentication check will fail and the request will be rejected. Challenge data is different for each session, so you need to extract and store the challenge data for each thread:

Extract <code>instance-id</code>
<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/extract_instance_id.png" alt="extract_instance_id"/>
Extract <code>device token</code>

<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/extractdevicetoken1.png" alt="extractdevicetoken" />

Change response status to HTTP 200
When JMeter performs initialization the first time, MFP Server will respond with an HTTP 401 status. This is as expected, so the performance tool should treat this HTTP status as a success, too. You may consider changing the HTTP status to HTTP 200. Otherwise, JMeter reports this request as “failed” and records it as an error, thus impacting significantly on the performance testing report.  

<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/changeresponeto200png1.png" alt="changeresponeto200png" />
</ul>


<ul>
<font size="4"><strong>Authorization2</strong></font> 
First, add the extracted values of the previous request (<code>device-token</code> + <code>instance-id</code>) as headers:

<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/antixsrf-headers-1024x164.png" alt="antixsrf headers" />

Now, execute the same authorization request again, with the same parameters. 
The expected response is 307 and the server sends the grant code:

<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/auth2response-1024x551.png" alt="auth2response" />
The grant code is extracted by JMeter:

<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/extract_grant_code-1024x336.png" alt="extract_grant_code"  />
</ul>
</ol>

<a name="Sign"></a>
<font size="5"><strong>Sign grant code</strong></font>
This phase is an internal JMeter operation in order to sign the grant code.
Ensure that the <code>jmeter.jwscreator</code> class name is selected. 
The class gets the <code>payload</code> parameter (extracted grant code) and signs the grant code with the constant public key, which was already inserted using the registration script.
The class signs the grant code and returns the <code>jws</code> parameter to be used as a header to get the access token:

<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/signgrantcodeclass-1024x183.png" alt="signgrantcodeclass" />

<a name="Token"></a>
<font size="5"><strong>Token</strong></font>
This is the final authorization step. At the end of this flow, the client receives the access token that will be used to access the resource endpoint.
Add the <code>X-WL-Authenticate</code> header, returned by the <code>sign grant code</code> Java request:

<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/x-wl-authenticate1.png" alt="x-wl-authenticate" />

Token request: Pass in four parameters including two dynamic – <code>client_id</code> and <code>code</code>: 

<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/tokenrequest-1024x633.png" alt="tokenrequest" />

In the response you get <code>access_token</code> and <code>id_token</code>:

<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/tokenresponse-1024x511.png" alt="tokenresponse"/>

Extract both parameters: <code>access_token</code> and <code>id_token</code>

<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/extractaccesstoken.png" alt="extractaccesstoken" />

<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/extract-id-token.png" alt="extract id token" />

<strong>The above steps should work as-is on any target server, assuming the server URL and context path are correct.
The context path is a user-defined parameter, and server URL can be configured in the </strong><strong>HTTP request defaults</strong> section.

<a name="Call"></a>
<font size="5"><strong>Sample of REST API call</strong></font>
This is a sample API call to a test adapter. Use your own adapter API.
This call demonstrates how to pass the <code>access_token</code> and <code>id_token</code> into the Authorization header.

Adding tokens to the authorization header
<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/tokensheaders1.png" alt="tokensheaders" />

Sample request showing how to access a resource endpoint with a REST API call:

<img src="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/callbills-1024x462.png" alt="callbills" />


<a name="Attachment"></a>
<strong>Attachment</strong>
The zip file <a href="{{site.baseurl}}/assets/blog/2015-12-20-mfp-performance-testing-session-independent-mode/perftestfiles.zip">perftestfiles</a> includes the following files:
1. JMeter script - Script file that demonstrates all the steps above
2. Grant code signer Java class - Java class that signs grant code
3. SQL script for DB2 convention - SQL insert command for DB2
4. <code>test </code>dummy application with <code>android</code> environment 

Tips when running the script:
•	Fill in the desired <strong>number of threads</strong> and <strong>loop count</strong> in <strong>data per user</strong>. It is recommended to start with one cycle for monitoring purposes. Ensure the single flow works as expected.
•	When running with more threads, do not forget to select the <strong>errors</strong> checkbox in the <strong>Flow results</strong> section to avoid a mass of write operations that will kill the JMeter.
•	You can also spread the script among several JMeter clients, or run it from the command line.
</ul>